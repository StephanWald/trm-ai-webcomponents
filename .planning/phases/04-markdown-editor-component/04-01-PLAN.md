---
phase: 04-markdown-editor-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sp-markdown-editor/types/editor.types.ts
  - src/components/sp-markdown-editor/utils/history-manager.ts
  - src/components/sp-markdown-editor/utils/markdown-renderer.ts
  - src/components/sp-markdown-editor/utils/file-handler.ts
  - src/components/sp-markdown-editor/utils/speech-recognizer.ts
  - src/components/sp-markdown-editor/sp-markdown-editor.tsx
  - src/components/sp-markdown-editor/sp-markdown-editor.css
autonomous: true

must_haves:
  truths:
    - "User sees a source mode textarea with monospace font for editing markdown"
    - "Editor footer displays character count, word count, and save indicator"
    - "Content auto-saves after 2-second debounce, emitting save event"
    - "Component exposes getContent, setContent, clear, getMode, setMode, isDirty, focus methods"
    - "Undo/redo history tracks up to 50 states"
  artifacts:
    - path: "src/components/sp-markdown-editor/types/editor.types.ts"
      provides: "TypeScript interfaces for editor mode, toolbar state, events, props"
      contains: "EditorMode"
    - path: "src/components/sp-markdown-editor/utils/history-manager.ts"
      provides: "Undo/redo stack with 50-state limit"
      exports: ["HistoryManager"]
    - path: "src/components/sp-markdown-editor/utils/markdown-renderer.ts"
      provides: "marked + DOMPurify rendering pipeline"
      exports: ["MarkdownRenderer"]
    - path: "src/components/sp-markdown-editor/utils/file-handler.ts"
      provides: "Import/export file operations"
      exports: ["FileHandler"]
    - path: "src/components/sp-markdown-editor/utils/speech-recognizer.ts"
      provides: "Web Speech API wrapper with feature detection"
      exports: ["SpeechRecognizer"]
    - path: "src/components/sp-markdown-editor/sp-markdown-editor.tsx"
      provides: "Core Stencil component with source mode, API methods, auto-save, footer"
      contains: "sp-markdown-editor"
    - path: "src/components/sp-markdown-editor/sp-markdown-editor.css"
      provides: "DWC-themed editor styles with source mode layout"
      contains: ":host"
  key_links:
    - from: "sp-markdown-editor.tsx"
      to: "history-manager.ts"
      via: "import and instantiation in component"
      pattern: "new HistoryManager"
    - from: "sp-markdown-editor.tsx"
      to: "types/editor.types.ts"
      via: "import of EditorMode, event interfaces"
      pattern: "import.*editor\\.types"
    - from: "sp-markdown-editor.tsx"
      to: "markdown-renderer.ts"
      via: "import for preview rendering"
      pattern: "new MarkdownRenderer"
---

<objective>
Create the sp-markdown-editor component foundation: TypeScript interfaces, all utility classes (history manager, markdown renderer, file handler, speech recognizer), and the core Stencil component with source mode editing, public API methods, auto-save with debounce, and character/word count footer. DWC-themed CSS styling.

Purpose: Establishes the entire component skeleton with types, utilities, and source mode — the single source of truth pattern. All subsequent plans extend this foundation with toolbar, WYSIWYG mode, and tests.
Output: Working component with source mode textarea, API methods, auto-save, and footer stats.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-markdown-editor-component/04-RESEARCH.md
@src/components/sp-walkthrough/sp-walkthrough.tsx (component patterns: @Component, @Prop, @State, @Event, @Method, @Watch)
@src/components/sp-walkthrough/types/walkthrough.types.ts (type pattern reference)
@src/global/dwc-theme.css (DWC token reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript interfaces and all utility classes</name>
  <files>
    src/components/sp-markdown-editor/types/editor.types.ts
    src/components/sp-markdown-editor/utils/history-manager.ts
    src/components/sp-markdown-editor/utils/markdown-renderer.ts
    src/components/sp-markdown-editor/utils/file-handler.ts
    src/components/sp-markdown-editor/utils/speech-recognizer.ts
  </files>
  <action>
    Create the types/ and utils/ directories under src/components/sp-markdown-editor/.

    **editor.types.ts** — Define all TypeScript interfaces:
    - `EditorMode`: type union 'source' | 'wysiwyg' | 'split'
    - `ToolbarState`: interface with boolean flags for bold, italic, strikethrough, code, heading (number), quote, codeBlock, bulletList, numberedList, taskList
    - `EditorStats`: interface with chars: number, words: number
    - `ContentChangeEvent`: interface with content: string, mode: EditorMode, timestamp: number
    - `SaveEvent`: interface with content: string, timestamp: number
    - `ModeChangeEvent`: interface with oldMode: EditorMode, newMode: EditorMode
    - `ImportEvent`: interface with filename: string, size: number, content: string
    - `ExportEvent`: interface with filename: string, size: number
    - `ImagePasteEvent`: interface with file: File, dataUrl: string

    **history-manager.ts** — Undo/redo stack following Pattern 2 from research:
    - Constructor accepts optional maxStates (default 50)
    - `push(state: string)`: Truncate forward history, add state, enforce maxStates limit
    - `undo(): string | null`: Move position back, return state or null
    - `redo(): string | null`: Move position forward, return state or null
    - `canUndo(): boolean` and `canRedo(): boolean`: Check position bounds
    - `clear()`: Reset history array and position
    - `getCurrent(): string | null`: Return current state without moving

    **markdown-renderer.ts** — Following Pattern 4 from research:
    - Constructor configures marked with GFM enabled, breaks: false
    - Check window.Prism availability for syntax highlighting — if available, use Prism.highlight in marked renderer; if not, fall back to unstyled code blocks
    - `render(markdown: string): string`: Call marked.parse() then DOMPurify.sanitize() with allowed tags (p, br, strong, em, del, code, pre, h1-h6, ul, ol, li, blockquote, a, img, table, thead, tbody, tr, th, td, hr, input, span, div, s) and allowed attrs (href, src, alt, title, class, type, checked, disabled)
    - Import marked and DOMPurify as peer dependencies. Use try-catch or typeof checks since they're peer deps — if missing, render() returns escaped plaintext and logs warning.
    - Add `del` and `s` tags for strikethrough support, `input` for task lists (checkboxes)

    **file-handler.ts** — Following Patterns 6, 7 from research:
    - `importFile(file: File): Promise<string>`: Read file as text with UTF-8 encoding via FileReader wrapped in Promise
    - `exportFile(content: string, filename?: string): { filename: string, size: number }`: Create Blob with text/markdown type, create temporary anchor, trigger download, cleanup with URL.revokeObjectURL. Default filename: `document-${Date.now()}.md`
    - Static methods (no instance state needed)

    **speech-recognizer.ts** — Following Pattern 5 from research:
    - Constructor: Feature-detect SpeechRecognition or webkitSpeechRecognition. If available, configure continuous=true, interimResults=true, lang='en-US'
    - `isSupported(): boolean`: Return whether recognition is available
    - `start(onResult: (text: string, isFinal: boolean) => void, onError?: (error: string) => void): void`: Set up onresult and onerror handlers, call start()
    - `stop(): void`: Stop recognition if active
    - `isActive(): boolean`: Return whether currently listening
    - `destroy(): void`: Stop and null out the recognition instance (for disconnectedCallback cleanup)
  </action>
  <verify>
    Run `npx stencil build` — should compile with no TypeScript errors for the new files. Check that all 5 files exist and export their classes/types.
  </verify>
  <done>
    All TypeScript interfaces defined in editor.types.ts. HistoryManager supports push/undo/redo/clear with 50-state limit. MarkdownRenderer wraps marked+DOMPurify pipeline with Prism fallback. FileHandler provides import/export. SpeechRecognizer wraps Web Speech API with feature detection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create core component with source mode, API, auto-save, and DWC styles</name>
  <files>
    src/components/sp-markdown-editor/sp-markdown-editor.tsx
    src/components/sp-markdown-editor/sp-markdown-editor.css
  </files>
  <action>
    **sp-markdown-editor.tsx** — Main Stencil component:

    @Component decorator: tag 'sp-markdown-editor', styleUrl, shadow: true

    **Props:**
    - `mode`: EditorMode = 'source' (default editing mode)
    - `value`: string = '' (initial content, reflects to attribute)
    - `placeholder`: string = 'Start typing markdown...'
    - `autoSave`: boolean = true (enable auto-save)
    - `autoSaveDelay`: number = 2000 (ms)
    - `maxHistory`: number = 50

    **State:**
    - `content`: string (single source of truth)
    - `currentMode`: EditorMode
    - `isDirtyState`: boolean = false
    - `isSaving`: boolean = false (for save indicator animation)
    - `isListening`: boolean = false (voice dictation active)
    - `toolbarState`: ToolbarState (for active format tracking)
    - `stats`: EditorStats

    **Events (EventEmitter):**
    - `contentChange`: ContentChangeEvent
    - `save`: SaveEvent
    - `modeChange`: ModeChangeEvent
    - `importFile`: ImportEvent (name importFile to avoid reserved word)
    - `exportFile`: ExportEvent
    - `imagePaste`: ImagePasteEvent

    **Private members:**
    - historyManager: HistoryManager (instantiated in componentWillLoad)
    - markdownRenderer: MarkdownRenderer (instantiated in componentWillLoad)
    - speechRecognizer: SpeechRecognizer (instantiated in componentWillLoad)
    - autoSaveTimer: ReturnType<typeof setTimeout> | null
    - sourceTextareaRef: HTMLTextAreaElement (via @Element or ref callback)

    **Lifecycle:**
    - componentWillLoad(): Initialize historyManager (with maxHistory), markdownRenderer, speechRecognizer. Set content from value prop. Push initial state to history.
    - disconnectedCallback(): Clear autoSaveTimer. Destroy speechRecognizer.

    **@Watch('value'):**
    - When value prop changes externally, update content and push to history

    **Content change handler (onInput on textarea):**
    - Update content from textarea value
    - Set isDirtyState = true
    - Push to historyManager (debounced — only push after 500ms pause in typing, but push immediately on paste or programmatic changes)
    - Emit contentChange event
    - Compute stats (chars, words)
    - Trigger auto-save debounce if autoSave enabled

    **Auto-save logic (following Pattern 6 from research):**
    - Clear existing autoSaveTimer on each content change
    - Set new timer for autoSaveDelay ms
    - On timer fire: emit save event, set isDirtyState=false, flash isSaving briefly

    **Stats computation:**
    - chars = content.length
    - words = content.trim().split(/\s+/).filter(w => w.length > 0).length (0 if empty)

    **@Method() public API methods (all async per Stencil requirement):**
    - getContent(): Promise<string> — return content
    - setContent(value: string): Promise<void> — set content, push to history, emit contentChange
    - clear(): Promise<void> — set content to '', clear history, emit contentChange
    - getMode(): Promise<EditorMode> — return currentMode
    - setMode(mode: EditorMode): Promise<void> — call mode switching logic
    - isDirty(): Promise<boolean> — return isDirtyState
    - focus(): Promise<void> — focus the source textarea

    **Render method:**
    - Container div with class "editor-container"
    - Toolbar area (placeholder div with class "toolbar" — Plan 02 will populate)
    - Editor body div with class "editor-body":
      - Source mode: <textarea> with monospace font, class "source-editor", value={content}, onInput handler, placeholder
      - WYSIWYG mode: placeholder div "wysiwyg-editor" (Plan 03 populates)
      - Split mode: show both side-by-side (Plan 03 populates)
      - Conditionally render based on currentMode
    - Footer div with class "editor-footer":
      - Character count span
      - Word count span
      - Save indicator (show "Saving..." when isSaving, "Unsaved changes" when isDirtyState, "Saved" when clean)
    - Use CSS parts: toolbar, source-editor, wysiwyg-editor, footer

    **sp-markdown-editor.css** — DWC-themed styles:

    Follow established DWC token pattern from sp-walkthrough and sp-org-chart:
    - :host { display: block; font-family: var(--dwc-font-family, 'Roboto', sans-serif); border: 1px solid var(--dwc-border-color, #ddd); border-radius: var(--dwc-border-radius, 4px); overflow: hidden; }
    - .toolbar { display: flex; flex-wrap: wrap; gap: 2px; padding: 4px 8px; background: var(--dwc-surface-color, #f5f5f5); border-bottom: 1px solid var(--dwc-border-color, #ddd); min-height: 36px; }
    - .editor-body { display: flex; flex: 1; min-height: 300px; overflow: hidden; }
    - .source-editor { width: 100%; height: 100%; min-height: 300px; padding: 12px 16px; border: none; outline: none; resize: vertical; font-family: var(--dwc-font-family-mono, 'Fira Code', 'Consolas', monospace); font-size: var(--dwc-font-size, 14px); line-height: 1.6; color: var(--dwc-color, #333); background: var(--dwc-background-color, #fff); tab-size: 2; }
    - .source-editor::placeholder { color: var(--dwc-color-disabled, #999); }
    - .editor-footer { display: flex; justify-content: space-between; align-items: center; padding: 4px 12px; background: var(--dwc-surface-color, #f5f5f5); border-top: 1px solid var(--dwc-border-color, #ddd); font-size: 12px; color: var(--dwc-color-secondary, #666); }
    - .stat-item { margin-right: 12px; }
    - .save-indicator { margin-left: auto; }
    - .save-indicator.saving { color: var(--dwc-color-warning, #f59e0b); }
    - .save-indicator.dirty { color: var(--dwc-color-warning, #f59e0b); }
    - .save-indicator.saved { color: var(--dwc-color-success, #10b981); }
    - :host(.theme-dark) .source-editor { background: var(--dwc-background-color, #1e1e1e); color: var(--dwc-color, #d4d4d4); }
    - Add ::part() selectors for toolbar, source-editor, wysiwyg-editor, footer
    - Print styles: @media print { .toolbar, .editor-footer { display: none; } }
  </action>
  <verify>
    Run `npx stencil build` — should compile with zero errors. The sp-markdown-editor tag should appear in build output. Run `npx stencil test --spec` — all existing tests should still pass (no regressions). Verify the component directory has all expected files.
  </verify>
  <done>
    sp-markdown-editor component renders source mode textarea with monospace font. Footer shows character/word count and save indicator. Auto-save emits save event after 2-second debounce. All 7 public API methods (getContent, setContent, clear, getMode, setMode, isDirty, focus) are implemented. HistoryManager, MarkdownRenderer, FileHandler, SpeechRecognizer utilities wired up. DWC-themed CSS with dark mode support.
  </done>
</task>

</tasks>

<verification>
1. `npx stencil build` completes with zero errors
2. `npx stencil test --spec` passes all existing + any new tests
3. Source mode textarea renders with monospace font
4. Character/word count updates on input
5. Auto-save indicator transitions: dirty -> saving -> saved
6. Public API methods are callable on the element
</verification>

<success_criteria>
- sp-markdown-editor component exists and builds successfully
- Source mode textarea renders with monospace font and DWC theming
- All 5 utility classes exist with proper exports
- Footer shows live character/word count
- Auto-save debounce works with 2-second delay
- 7 public API methods are available on the component
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/04-markdown-editor-component/04-01-SUMMARY.md`
</output>
