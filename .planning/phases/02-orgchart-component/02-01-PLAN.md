---
phase: 02-orgchart-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sp-org-chart/types/org-chart.types.ts
  - src/components/sp-org-chart/utils/tree-builder.ts
  - src/components/sp-org-chart/utils/tree-filter.ts
  - src/components/sp-org-chart/utils/tree-sorter.ts
  - src/components/sp-org-chart/sp-org-chart.tsx
  - src/components/sp-org-chart/sp-org-chart.css
autonomous: true

must_haves:
  truths:
    - "Developer provides flat user array with reportsTo and sees hierarchical tree rendered"
    - "Visual connectors (CSS borders) link parent-child relationships"
    - "Users within each level are sorted alphabetically by name"
    - "Empty user array displays custom no-data message"
    - "Editable mode can be toggled on/off via attribute"
    - "Component emits user-click, user-dblclick, hierarchy-change, user-delete events"
    - "Component exposes getSelected(), highlightUser(), clearHighlight(), scrollToUser() methods"
  artifacts:
    - path: "src/components/sp-org-chart/types/org-chart.types.ts"
      provides: "User, TreeNode, FilterResult interfaces"
      contains: "interface User"
    - path: "src/components/sp-org-chart/utils/tree-builder.ts"
      provides: "buildTree function with cycle detection"
      exports: ["buildTree"]
    - path: "src/components/sp-org-chart/utils/tree-filter.ts"
      provides: "filterTree function with ancestor chain preservation"
      exports: ["filterTree"]
    - path: "src/components/sp-org-chart/utils/tree-sorter.ts"
      provides: "sortTree alphabetical sorting within levels"
      exports: ["sortTree"]
    - path: "src/components/sp-org-chart/sp-org-chart.tsx"
      provides: "Main component class with rendering, events, methods"
      contains: "@Component"
    - path: "src/components/sp-org-chart/sp-org-chart.css"
      provides: "Component styles with DWC tokens, connectors, drop zones"
      contains: ":host"
  key_links:
    - from: "sp-org-chart.tsx"
      to: "types/org-chart.types.ts"
      via: "import { User, TreeNode, FilterResult }"
      pattern: "import.*org-chart\\.types"
    - from: "sp-org-chart.tsx"
      to: "utils/tree-builder.ts"
      via: "import { buildTree }"
      pattern: "import.*tree-builder"
    - from: "sp-org-chart.tsx"
      to: "utils/tree-filter.ts"
      via: "import { filterTree }"
      pattern: "import.*tree-filter"
    - from: "sp-org-chart.tsx"
      to: "utils/tree-sorter.ts"
      via: "import { sortTree }"
      pattern: "import.*tree-sorter"
---

<objective>
Create the sp-org-chart web component with types, utility functions, complete rendering, interactions, filtering, and public API.

Purpose: This is the full OrgChart component — the first real Skillspilot component that validates all patterns established in Phase 1 (DWC theming, Shadow DOM, events, methods) while implementing hierarchical tree rendering with drag-and-drop, filtering, selection, and long-press deletion.

Output: A complete, functional sp-org-chart component with all 13 ORGC requirements implemented, ready for testing in Plan 02.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-orgchart-component/02-RESEARCH.md
@src/components/sp-example/sp-example.tsx
@src/components/sp-example/sp-example.css
@src/global/dwc-theme.css
@stencil.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and utility functions</name>
  <files>
    src/components/sp-org-chart/types/org-chart.types.ts
    src/components/sp-org-chart/utils/tree-builder.ts
    src/components/sp-org-chart/utils/tree-filter.ts
    src/components/sp-org-chart/utils/tree-sorter.ts
  </files>
  <action>
    Create the type definitions and pure utility functions for the org chart component.

    **Types (org-chart.types.ts):**
    - `User` interface: id (string), name (string), role (string), reportsTo (string | undefined), avatar (string | undefined — optional image URL)
    - `TreeNode` interface: extends User with children (TreeNode[]), level (number)
    - `FilterResult` interface: node (TreeNode), matched (boolean), hasMatchingDescendant (boolean), isAncestorOfMatch (boolean)
    - `HierarchyChangeDetail` interface: userId (string), oldManagerId (string | null), newManagerId (string | null)
    - `UserEventDetail` interface: userId (string), user (User)

    **Tree builder (tree-builder.ts):**
    - `buildTree(users: User[]): TreeNode[]` — Two-pass Map-based algorithm (O(n)):
      - Pass 1: Create TreeNode entries in Map with empty children arrays
      - Pass 2: Wire parent-child using reportsTo, detect cycles using ancestor Set traversal
      - Orphaned nodes (parent not found) become roots
      - Returns array of root TreeNode(s)
    - Handle edge cases: empty array returns [], null/undefined reportsTo = root, circular references logged with console.warn and treated as roots

    **Tree filter (tree-filter.ts):**
    - `filterTree(roots: TreeNode[], predicate: (node: TreeNode) => boolean): Map<string, FilterResult>` — Two-pass DFS:
      - Pass 1 (DFS bottom-up): Mark direct matches and hasMatchingDescendant
      - Pass 2 (DFS top-down): Mark isAncestorOfMatch for ancestors of matched nodes
      - Returns Map<string, FilterResult> keyed by user ID
    - Predicate receives TreeNode, returns boolean (allows name/role matching by caller)
    - If predicate matches a node: show that node + ALL subordinates + full chain of command to root. Non-matching, non-ancestor, non-descendant nodes should be dimmed.

    **Tree sorter (tree-sorter.ts):**
    - `sortTree(nodes: TreeNode[]): TreeNode[]` — Recursive alphabetical sort:
      - Sort nodes at current level by name using localeCompare with { sensitivity: 'base' }
      - Recursively sort each node's children
      - Returns NEW sorted array (does not mutate input)
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript compilation errors.
    Verify all 4 files exist and export their functions/interfaces.
  </verify>
  <done>
    Types define User, TreeNode, FilterResult, HierarchyChangeDetail, UserEventDetail.
    buildTree converts flat array to tree with cycle detection.
    filterTree performs two-pass DFS with ancestor chain preservation.
    sortTree recursively sorts alphabetically within levels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sp-org-chart component with full rendering, interactions, and API</name>
  <files>
    src/components/sp-org-chart/sp-org-chart.tsx
    src/components/sp-org-chart/sp-org-chart.css
  </files>
  <action>
    Create the complete sp-org-chart component implementing ALL requirements (ORGC-01 through ORGC-13).

    **Component class (sp-org-chart.tsx):**

    Follow sp-example.tsx patterns: @Component with shadow: true, tag: 'sp-org-chart', styleUrl.

    **Props (@Prop):**
    - `users: User[]` — Flat array of users with reportsTo relationships (default: [])
    - `editable: boolean` — Enable/disable edit mode for drag-and-drop and deletion (default: false)
    - `noDataMessage: string` — Custom message when users array is empty (default: 'No data available')
    - `theme: 'light' | 'dark' | 'auto'` — Theme override (default: 'auto') — follow sp-example pattern

    **State (@State):**
    - `treeData: TreeNode[]` — Computed tree from users prop
    - `selectedUserId: string | null` — Currently selected user
    - `highlightedUserId: string | null` — Programmatically highlighted user
    - `filterText: string` — Current filter input value
    - `filterResults: Map<string, FilterResult> | null` — Active filter results
    - `draggedUserId: string | null` — User being dragged
    - `showDropZones: boolean` — Whether drop zones are visible
    - `dropTargetId: string | null` — Current drop target being hovered
    - `longPressUserId: string | null` — User undergoing long-press
    - `longPressProgress: number` — 0-1 countdown progress

    **Watch (@Watch):**
    - Watch `users` prop: Rebuild tree using buildTree() + sortTree(), clear filter results

    **Events (@Event):**
    - `userClick: EventEmitter<UserEventDetail>` — Single-click on user tile
    - `userDblclick: EventEmitter<UserEventDetail>` — Double-click on user tile
    - `hierarchyChange: EventEmitter<HierarchyChangeDetail>` — After drag-and-drop reassignment
    - `userDelete: EventEmitter<UserEventDetail>` — After long-press deletion completes

    **Methods (@Method):**
    All must be async (Stencil requirement for lazy-loaded components).
    - `getSelected(): Promise<User | null>` — Return selected user or null
    - `highlightUser(userId: string): Promise<void>` — Set highlighted user
    - `clearHighlight(): Promise<void>` — Clear highlight
    - `scrollToUser(userId: string): Promise<void>` — Scroll user tile into view using el.shadowRoot.querySelector(`[data-user-id="${userId}"]`).scrollIntoView({ behavior: 'smooth', block: 'center' })

    **Interaction handlers (private methods):**

    1. **Click/Double-click (ORGC-07, ORGC-08):**
       - Use a timer-based approach: On click, set a 300ms timeout for single-click. If another click arrives before timeout, clear timer and fire double-click instead.
       - Single-click: Set selectedUserId, emit userClick with user data
       - Double-click: Emit userDblclick with user data

    2. **Drag-and-drop (ORGC-04, ORGC-05):**
       - Only active when `editable` is true
       - `handleDragStart(ev, userId)`: Set dataTransfer data, store draggedUserId, show drop zones
       - `handleDragOver(ev, targetId)`: preventDefault (CRITICAL), stopPropagation, set dropTargetId
       - `handleDragLeave(ev)`: Clear dropTargetId
       - `handleDrop(ev, newManagerId)`: Get dragged user, find old manager, update user's reportsTo in users array, rebuild tree, emit hierarchyChange event, cleanup drag state
       - `handleDragEnd(ev)`: Cleanup drag state regardless of drop success
       - Drop on "Unlink" zone: Set reportsTo to undefined (makes user a root)
       - Drop on "Delete" zone: Remove user from array, emit userDelete, rebuild tree

    3. **Long-press deletion (ORGC-09):**
       - Only active when `editable` is true
       - `handlePointerDown(ev, userId)`: Store start position, set longPressUserId, start setInterval (16ms ~60fps) tracking elapsed time as longPressProgress (0-1 over 4000ms)
       - `handlePointerMove(ev)`: If moved >10px from start, cancel long-press
       - `handlePointerUp(ev)`: Cancel long-press
       - When longPressProgress reaches 1: Remove user from array, emit userDelete, rebuild tree, cleanup
       - `disconnectedCallback()`: Clear all timers (long-press interval, click timeout)
       - Render countdown as SVG circular progress indicator on the user tile

    4. **Filtering (ORGC-06):**
       - Filter input at the top of the component
       - On input change: If filter text is non-empty, call filterTree with predicate checking name.toLowerCase().includes(filterText) || role.toLowerCase().includes(filterText)
       - If filter text is empty, clear filterResults (show all)
       - During rendering, if filterResults exists: add CSS class 'dimmed' to nodes that are NOT (matched || hasMatchingDescendant || isAncestorOfMatch)

    **Render method:**

    ```
    render() {
      return (
        <Host class={{ 'theme-light': theme==='light', 'theme-dark': theme==='dark' }}>
          {/* Filter input */}
          <div class="org-chart-toolbar">
            <input type="text" class="filter-input" placeholder="Filter by name or role..." onInput={handleFilterInput} value={filterText} part="filter-input" />
          </div>

          {/* No data message */}
          {users.length === 0 && <div class="no-data" part="no-data">{noDataMessage}</div>}

          {/* Tree container */}
          {users.length > 0 && (
            <div class="tree-container" part="tree-container">
              {treeData.map(root => renderTreeNode(root))}
            </div>
          )}

          {/* Drop zones (visible during drag when editable) */}
          {editable && showDropZones && renderDropZones()}
        </Host>
      );
    }
    ```

    **renderTreeNode(node: TreeNode)** — Recursive rendering:
    - Render user tile with data-user-id attribute
    - Apply CSS classes: 'selected' if selectedUserId matches, 'highlighted' if highlightedUserId matches, 'dimmed' if filter active and node is not relevant, 'drag-over' if dropTargetId matches
    - Make draggable only when editable
    - Attach event handlers: onClick, onDragStart, onDragOver, onDrop, onDragLeave, onDragEnd, onPointerDown, onPointerUp, onPointerMove
    - User tile shows: avatar (or initials circle if no avatar), name, role
    - If node has children: render children container with CSS connector lines
    - If long-press active on this node: render SVG countdown circle overlay
    - Each user tile gets part="user-tile" for external styling

    **renderDropZones():**
    - Two zones: "Unlink" (removes manager) and "Delete" (removes user)
    - Each zone has onDragOver (preventDefault), onDrop handler
    - CSS: dashed border, icons, hover state with scale effect

    **CSS file (sp-org-chart.css):**

    Follow sp-example.css patterns — consume DWC tokens with var(--dwc-*) throughout.

    - `:host` — display: block, font-family: var(--dwc-font-family), overflow: auto
    - `.org-chart-toolbar` — padding, flex layout for filter input
    - `.filter-input` — DWC-styled input (border, border-radius, padding, font-family from DWC tokens)
    - `.no-data` — Centered text with DWC muted color, padding
    - `.tree-container` — Display flex, flex-direction column, align-items center, padding
    - `.tree-node` — Display flex, flex-direction column, align-items center
    - `.tree-children` — Display flex, flex-direction row, justify-content center, gap, position relative
    - **CSS Connectors:** Use ::before and ::after pseudo-elements on .tree-children and .tree-node:
      - Vertical line from parent tile bottom to children row top (using ::after on parent wrapper)
      - Horizontal line connecting siblings (using ::before on .tree-children)
      - Individual vertical drops from horizontal line to each child (using ::before on each child .tree-node)
      - All connector lines: 2px solid var(--dwc-color-border)
    - `.user-tile` — Background var(--dwc-color-surface), border 1px solid var(--dwc-color-border), border-radius var(--dwc-border-radius), padding var(--dwc-spacing-md), min-width 150px, cursor pointer, transition, box-shadow var(--dwc-shadow-sm)
    - `.user-tile:hover` — box-shadow: var(--dwc-shadow-md)
    - `.user-tile.selected` — border: 2px solid var(--dwc-color-primary), box-shadow: 0 0 0 3px rgba(primary, 0.2)
    - `.user-tile.highlighted` — border: 2px solid var(--dwc-color-warning, #f59e0b), background with subtle highlight
    - `.user-tile.dimmed` — opacity: 0.3, pointer-events: none
    - `.user-tile.drag-over` — border: 2px dashed var(--dwc-color-primary), background with subtle highlight
    - `.user-tile .avatar` — 40px circle, background var(--dwc-color-primary), color white, centered initials, or img if avatar URL
    - `.user-tile .user-name` — font-weight var(--dwc-font-weight-semibold)
    - `.user-tile .user-role` — color var(--dwc-color-text-secondary), font-size var(--dwc-font-size-sm)
    - `.drop-zones` — Fixed bottom, flex row, gap, padding
    - `.drop-zone` — border 2px dashed var(--dwc-color-border), border-radius, padding, transition
    - `.drop-zone:hover` / `.drop-zone.drag-over` — border-color primary, background subtle, transform scale(1.05)
    - `.drop-zone--delete` hover state — border-color var(--dwc-color-danger, #ef4444)
    - `.countdown-ring` — Positioned absolute over user tile, SVG styling
    - Theme overrides: :host(.theme-light) and :host(.theme-dark) following sp-example patterns
    - `[draggable="true"]` — cursor: grab
    - `[draggable="true"]:active` — cursor: grabbing

    **Lifecycle:**
    - `componentWillLoad()`: Build initial tree from users prop
    - `disconnectedCallback()`: Clean up all timers (longPressTimer, clickTimer)
  </action>
  <verify>
    Run `npm run build` — build succeeds without errors.
    Verify component renders in `src/index.html` by adding a demo section:
    Add a `<sp-org-chart>` element to src/index.html with sample data (via script tag setting .users property).
    Run `npm start` to verify dev server loads without errors.
  </verify>
  <done>
    sp-org-chart component renders hierarchical tree from flat user array with visual connectors.
    Users are sorted alphabetically within each level.
    Drag-and-drop reassigns managers and emits hierarchy-change event (when editable=true).
    Drop zones appear during drag (Unlink, Delete).
    Filter input shows matching users with dimmed non-matches.
    Single-click selects, double-click emits event, long-press triggers deletion with countdown.
    Public API methods (getSelected, highlightUser, clearHighlight, scrollToUser) are exposed.
    Empty array shows no-data message. Editable mode toggleable via attribute.
    All DWC tokens consumed for consistent theming. Theme light/dark overrides work.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. Component renders in dev server (`npm start`) showing hierarchical tree
3. Filter input filters by name/role with proper dimming
4. Drag-and-drop moves users between managers (when editable)
5. Click selects tile with blue border, double-click fires event
6. Long-press shows countdown and triggers deletion
7. Drop zones appear during drag operations
8. No-data message shown for empty array
9. `npx tsc --noEmit` passes — no TypeScript errors
</verification>

<success_criteria>
- All 13 ORGC requirements implemented (ORGC-01 through ORGC-13)
- Component follows sp-example patterns (DWC theming, Shadow DOM, events, props)
- Utility functions are pure and separated from component logic
- Build produces dist output without errors
- Component is ready for test suite (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-orgchart-component/02-01-SUMMARY.md`
</output>
