---
phase: 03-walkthrough-component
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sp-walkthrough/types/walkthrough.types.ts
  - src/components/sp-walkthrough/utils/overlay-manager.ts
  - src/components/sp-walkthrough/utils/timeline-engine.ts
  - src/components/sp-walkthrough/utils/youtube-wrapper.ts
  - src/components/sp-walkthrough/utils/draggable-mixin.ts
  - src/components/sp-walkthrough/sp-walkthrough.tsx
  - src/components/sp-walkthrough/sp-walkthrough.css
  - src/index.html
autonomous: true

must_haves:
  truths:
    - "User sees walkthrough panel in fixed position (lower-right default) playing video"
    - "Timeline advances scenes automatically at configured timestamps during video playback"
    - "DOM elements outside component boundary are highlighted with visual overlays during active scene"
    - "Component supports both standard video files (MP4/WebM) and YouTube embeds"
    - "Manual navigation (prev/next) works when no video is present"
    - "User can drag the walkthrough panel to reposition it on screen"
    - "WebVTT captions display with toggle on/off capability"
    - "Volume control with mute/unmute functions correctly"
    - "Scene list dropdown allows jumping to specific scenes"
    - "ESC key aborts walkthrough, cleaning up overlays and hiding panel"
    - "Component emits walkthrough-shown, walkthrough-hidden, walkthrough-aborted, scene-changed events"
    - "Component exposes show(), hide(), play(), pause(), restart(), abort() methods"
  artifacts:
    - path: "src/components/sp-walkthrough/types/walkthrough.types.ts"
      provides: "Scene, TimelineEntry, WalkthroughConfig, event detail interfaces"
      contains: "interface Scene"
    - path: "src/components/sp-walkthrough/utils/overlay-manager.ts"
      provides: "DOM overlay creation, positioning, scroll/resize tracking, cleanup"
      exports: ["OverlayManager"]
    - path: "src/components/sp-walkthrough/utils/timeline-engine.ts"
      provides: "Scene advancement logic based on currentTime"
      exports: ["TimelineEngine"]
    - path: "src/components/sp-walkthrough/utils/youtube-wrapper.ts"
      provides: "YouTube IFrame API wrapper with normalized VideoPlayer interface"
      exports: ["YouTubePlayerWrapper", "isYouTubeUrl", "extractVideoId"]
    - path: "src/components/sp-walkthrough/utils/draggable-mixin.ts"
      provides: "PointerEvent-based panel drag behavior with viewport constraints"
      exports: ["makeDraggable"]
    - path: "src/components/sp-walkthrough/sp-walkthrough.tsx"
      provides: "Main component with video playback, timeline sync, navigation, controls"
      contains: "@Component"
    - path: "src/components/sp-walkthrough/sp-walkthrough.css"
      provides: "Panel styles, controls, overlays, DWC theming"
      contains: ":host"
  key_links:
    - from: "sp-walkthrough.tsx"
      to: "types/walkthrough.types.ts"
      via: "import { Scene, TimelineEntry, ... }"
      pattern: "import.*walkthrough\\.types"
    - from: "sp-walkthrough.tsx"
      to: "utils/overlay-manager.ts"
      via: "import { OverlayManager }"
      pattern: "import.*overlay-manager"
    - from: "sp-walkthrough.tsx"
      to: "utils/timeline-engine.ts"
      via: "import { TimelineEngine }"
      pattern: "import.*timeline-engine"
    - from: "sp-walkthrough.tsx"
      to: "utils/youtube-wrapper.ts"
      via: "import { YouTubePlayerWrapper, isYouTubeUrl }"
      pattern: "import.*youtube-wrapper"
    - from: "sp-walkthrough.tsx"
      to: "utils/draggable-mixin.ts"
      via: "import { makeDraggable }"
      pattern: "import.*draggable-mixin"
---

<objective>
Create the sp-walkthrough web component with types, utility modules, complete rendering, video playback (standard + YouTube), timeline synchronization, DOM element highlighting, manual navigation, draggable panel, volume/captions controls, scene dropdown, and public API.

Purpose: This is the core walkthrough component implementing all non-author-mode requirements (WALK-01 through WALK-06, WALK-10 through WALK-15). It validates cross-shadow-boundary DOM interaction patterns and video timeline synchronization, establishing the foundation for author mode in Plan 02.

Output: A complete, functional sp-walkthrough component (minus author mode) with all utility modules, ready for author mode extension in Plan 02.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-walkthrough-component/03-RESEARCH.md
@src/components/sp-org-chart/sp-org-chart.tsx
@src/components/sp-org-chart/sp-org-chart.css
@src/components/sp-example/sp-example.tsx
@src/components/sp-example/sp-example.css
@src/global/dwc-theme.css
@stencil.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create types and utility modules</name>
  <files>
    src/components/sp-walkthrough/types/walkthrough.types.ts
    src/components/sp-walkthrough/utils/overlay-manager.ts
    src/components/sp-walkthrough/utils/timeline-engine.ts
    src/components/sp-walkthrough/utils/youtube-wrapper.ts
    src/components/sp-walkthrough/utils/draggable-mixin.ts
  </files>
  <action>
    Create the type definitions and utility modules for the walkthrough component.

    **Types (walkthrough.types.ts):**
    - `Scene` interface: id (string), title (string), description (string, optional), timestamp (number — seconds, for video-synced scenes), highlightSelector (string, optional — CSS selector for DOM element to highlight), duration (number, optional — seconds, for manual mode auto-advance)
    - `WalkthroughConfig` interface: scenes (Scene[]), videoSrc (string, optional — URL for MP4/WebM/YouTube), captionsSrc (string, optional — WebVTT URL), autoPlay (boolean, optional, default false), position (object, optional — { bottom: number, right: number } default panel position)
    - `SceneChangeDetail` interface: sceneId (string), sceneIndex (number), timestamp (number)
    - `TimelineUpdateDetail` interface: scenes (Scene[]), changeType ('create' | 'update' | 'delete'), affectedSceneId (string)
    - `VideoPlayer` interface: play(): void, pause(): void, getCurrentTime(): number, getDuration(): number, seekTo(seconds: number): void, setVolume(volume: number): void, isMuted(): boolean, setMuted(muted: boolean): void, on(event: string, callback: Function): void, off(event: string, callback: Function): void, destroy(): void

    **Overlay Manager (overlay-manager.ts):**
    Class `OverlayManager` that manages DOM overlays appended to document.body to escape shadow DOM boundaries.

    - `constructor()` — Initialize empty overlays array and AbortController for event cleanup
    - `highlightElement(selector: string): void` — Clear existing highlights, find element via document.querySelector(selector), get position via getBoundingClientRect(), create fixed-position overlay div with class 'sp-walkthrough-highlight', set styles: position fixed, top/left/width/height from rect, zIndex 10000, pointerEvents none, border 3px solid var(--dwc-color-primary, #0066cc), borderRadius 4px, boxShadow '0 0 0 9999px rgba(0,0,0,0.5)' for spotlight effect, transition 'all 0.3s ease'. Append to document.body. Add scroll and resize listeners (using AbortController signal) that update position via requestAnimationFrame throttling (track pending rAF flag to avoid stacking). If element not found, console.warn and return.
    - `clearHighlights(): void` — Remove all overlay elements from DOM, abort AbortController, create new AbortController
    - `cleanup(): void` — Call clearHighlights, null out references
    - `updatePositions(): void` — For each active overlay, re-query getBoundingClientRect on stored target element reference and update overlay position. Called by scroll/resize listeners.

    Store target element reference alongside each overlay for position updates. Use an array of `{ overlay: HTMLElement, target: Element }` objects.

    **Timeline Engine (timeline-engine.ts):**
    Class `TimelineEngine` that manages scene advancement based on video currentTime.

    - `constructor(scenes: Scene[])` — Store scenes sorted by timestamp ascending
    - `getCurrentSceneIndex(currentTime: number): number` — Find latest scene where timestamp <= currentTime. Use reverse iteration for efficiency (scenes already sorted). Returns -1 if currentTime is before first scene.
    - `getScene(index: number): Scene | null` — Return scene at index or null
    - `getSceneCount(): number` — Return number of scenes
    - `setScenes(scenes: Scene[]): void` — Update scenes array (re-sort by timestamp)
    - `getNextScene(currentIndex: number): Scene | null` — Return next scene or null if at end
    - `getPreviousScene(currentIndex: number): Scene | null` — Return previous scene or null if at start

    This is a pure data utility — no event handling. The component handles timeupdate events and calls getCurrentSceneIndex().

    **YouTube Wrapper (youtube-wrapper.ts):**
    Class `YouTubePlayerWrapper` implementing the `VideoPlayer` interface to normalize YouTube IFrame API.

    - `static isYouTubeUrl(url: string): boolean` — Check if URL matches youtube.com/watch, youtu.be, or youtube.com/embed patterns
    - `static extractVideoId(url: string): string | null` — Extract video ID from YouTube URL using regex
    - `constructor(containerElement: HTMLElement, videoId: string)` — Load YouTube IFrame API script if not already loaded (check window.YT), create player when ready. Queue commands received before player is ready.
    - Implement all VideoPlayer interface methods:
      - `play()` → player.playVideo()
      - `pause()` → player.pauseVideo()
      - `getCurrentTime()` → player.getCurrentTime() || 0
      - `getDuration()` → player.getDuration() || 0
      - `seekTo(seconds)` → player.seekTo(seconds, true)
      - `setVolume(volume)` → player.setVolume(volume * 100) (YouTube uses 0-100)
      - `isMuted()` → player.isMuted() || false
      - `setMuted(muted)` → muted ? player.mute() : player.unMute()
      - `on(event, callback)` → store in listeners Map
      - `off(event, callback)` → remove from listeners Map
      - `destroy()` → stop time tracking, player.destroy()
    - Start 250ms setInterval for time tracking when playing (simulates timeupdate event since YouTube API doesn't provide one). Emit 'timeupdate' to listeners. Stop interval when paused/ended.
    - Handle YT.PlayerState changes: PLAYING starts tracking, PAUSED/ENDED stops tracking, emit corresponding events ('play', 'pause', 'ended')

    Export helper functions: `isYouTubeUrl(url: string): boolean` and `extractVideoId(url: string): string | null` as standalone exports alongside the class.

    **Draggable Mixin (draggable-mixin.ts):**
    Function `makeDraggable(element: HTMLElement, handleSelector: string): () => void` — Attaches PointerEvent-based drag behavior to element, returning a cleanup function.

    - Find drag handle via element.querySelector(handleSelector) or use element itself if not found
    - On pointerdown on handle: record start position (clientX/Y) and element's current position (getBoundingClientRect), set pointer capture, set document.body.style.cursor = 'grabbing'
    - On pointermove (document-level, only while dragging): calculate delta, compute new position, constrain to viewport bounds (0 to window.innerWidth - element.offsetWidth, 0 to window.innerHeight - element.offsetHeight), set element.style.left/top, clear element.style.right/bottom (switch from right/bottom positioning to left/top during drag)
    - On pointerup: release pointer capture, reset cursor, clear drag state
    - Use AbortController for all event listener cleanup
    - Return cleanup function that aborts controller
  </action>
  <verify>
    Run `npx tsc --noEmit` — no TypeScript compilation errors.
    Verify all 5 files exist and export their types/classes/functions.
  </verify>
  <done>
    Types define Scene, WalkthroughConfig, SceneChangeDetail, TimelineUpdateDetail, VideoPlayer interface.
    OverlayManager creates/positions/cleans up fixed overlays on document.body with scroll/resize tracking.
    TimelineEngine provides pure scene lookup by currentTime with sorted scene management.
    YouTubePlayerWrapper normalizes YouTube IFrame API to VideoPlayer interface with time tracking.
    makeDraggable attaches PointerEvent-based drag with viewport constraints and returns cleanup function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create sp-walkthrough component with rendering, video, timeline, navigation, and controls</name>
  <files>
    src/components/sp-walkthrough/sp-walkthrough.tsx
    src/components/sp-walkthrough/sp-walkthrough.css
    src/index.html
  </files>
  <action>
    Create the complete sp-walkthrough component implementing WALK-01 through WALK-06 and WALK-10 through WALK-15. Author mode (WALK-07/08/09) deferred to Plan 02.

    **Component class (sp-walkthrough.tsx):**

    Follow sp-org-chart.tsx patterns: @Component with shadow: true, tag: 'sp-walkthrough', styleUrl.

    **Props (@Prop):**
    - `scenes: Scene[]` — Array of scene definitions (default: [])
    - `videoSrc: string` — Video URL (MP4, WebM, or YouTube URL). Optional — if absent, manual navigation mode.
    - `captionsSrc: string` — WebVTT captions file URL. Optional.
    - `autoPlay: boolean` — Auto-play video when walkthrough shown (default: false)
    - `authorMode: boolean` — Enable author mode editing (default: false) — wired in Plan 02, prop declared here
    - `theme: 'light' | 'dark' | 'auto'` — Theme override (default: 'auto')

    **State (@State):**
    - `isVisible: boolean` — Whether walkthrough panel is shown (default: false)
    - `currentSceneIndex: number` — Currently active scene index (default: -1, meaning no scene active)
    - `isPlaying: boolean` — Video playback state
    - `volume: number` — Volume level 0-1 (default: 1.0)
    - `isMuted: boolean` — Muted state (default: false)
    - `captionsEnabled: boolean` — Caption track visibility (default: false)
    - `currentTime: number` — Current video playback time in seconds
    - `duration: number` — Total video duration in seconds

    **Watch (@Watch):**
    - Watch `scenes` prop: Update timeline engine with new scenes, reset currentSceneIndex to -1
    - Watch `videoSrc` prop: Destroy existing video player, initialize new one

    **Events (@Event) — WALK-13:**
    - `walkthroughShown: EventEmitter<void>` — Panel becomes visible
    - `walkthroughHidden: EventEmitter<void>` — Panel hidden normally
    - `walkthroughAborted: EventEmitter<void>` — ESC key or abort() called
    - `sceneChanged: EventEmitter<SceneChangeDetail>` — Scene transition occurred
    - `timelineUpdated: EventEmitter<TimelineUpdateDetail>` — Timeline modified (used by author mode in Plan 02)

    **Methods (@Method) — WALK-14:**
    All async (Stencil requirement).
    - `show(): Promise<void>` — Set isVisible=true, add ESC keydown listener on document, start video if autoPlay, emit walkthroughShown
    - `hide(): Promise<void>` — Set isVisible=false, pause video, clear overlays, remove ESC listener, emit walkthroughHidden
    - `play(): Promise<void>` — Resume video playback (videoElement.play() or youtubeWrapper.play())
    - `pause(): Promise<void>` — Pause video playback
    - `restart(): Promise<void>` — Seek to 0, reset currentSceneIndex to 0, play
    - `abort(): Promise<void>` — Clear overlays, reset state (currentSceneIndex=-1, isVisible=false), pause video, remove ESC listener, emit walkthroughAborted

    **Private members:**
    - `videoElement: HTMLVideoElement | null` — Reference to native video element (set via ref callback in JSX)
    - `youtubeWrapper: YouTubePlayerWrapper | null` — YouTube player wrapper instance
    - `overlayManager: OverlayManager` — Overlay manager instance
    - `timelineEngine: TimelineEngine` — Timeline engine instance
    - `dragCleanup: (() => void) | null` — Cleanup function from makeDraggable
    - `escapeHandler: (ev: KeyboardEvent) => void` — Named ESC key handler for removal
    - `isYouTube: boolean` — Computed: whether videoSrc is a YouTube URL
    - `timeUpdateHandler: () => void` — Named handler for timeupdate events

    **Lifecycle:**
    - `componentWillLoad()`: Initialize overlayManager and timelineEngine from scenes prop. Determine isYouTube from videoSrc.
    - `componentDidLoad()`: If videoSrc is YouTube, create YouTubePlayerWrapper. Attach makeDraggable to panel element via drag handle. Set up escapeHandler = (ev) => { if (ev.key === 'Escape') this.abort(); }.
    - `componentDidUpdate()`: After render, if isVisible and currentSceneIndex changed, update overlay highlight.
    - `disconnectedCallback()`: Clean up everything — overlayManager.cleanup(), youtubeWrapper?.destroy(), dragCleanup?.(), remove ESC listener from document.

    **Video handling (WALK-01, WALK-04):**
    - For standard video: Render `<video>` element with src, controls attribute removed (custom controls), onTimeUpdate handler, onLoadedMetadata (set duration), onPlay/onPause (update isPlaying state). If captionsSrc, add `<track>` element.
    - For YouTube: Render container div with ref, YouTubePlayerWrapper handles player creation.
    - `timeUpdateHandler`: Get currentTime from video/youtube, update this.currentTime state, call timelineEngine.getCurrentSceneIndex(currentTime). If index changed from currentSceneIndex, update currentSceneIndex, call overlayManager with new scene's highlightSelector, emit sceneChanged.

    **Timeline sync (WALK-02, WALK-03):**
    - On timeupdate (standard video) or 250ms interval (YouTube): Call timelineEngine.getCurrentSceneIndex(currentTime). If different from currentSceneIndex, advance scene.
    - advanceToScene(index): Set currentSceneIndex, get scene from timelineEngine. If scene.highlightSelector exists, call overlayManager.highlightElement(selector). Else call overlayManager.clearHighlights(). Emit sceneChanged event.

    **Manual navigation (WALK-05):**
    - When videoSrc is absent, show prev/next buttons and scene counter.
    - nextScene(): If currentSceneIndex < scenes.length - 1, advance to next scene. Trigger highlight update.
    - previousScene(): If currentSceneIndex > 0, go to previous scene.
    - Both call advanceToScene(index).

    **Draggable panel (WALK-06):**
    - Panel is fixed-position div. Default: bottom-right (bottom: 20px, right: 20px).
    - Drag handle: top bar of panel with class 'drag-handle'.
    - makeDraggable called in componentDidLoad on the panel element.

    **Captions (WALK-10):**
    - Standard video: Add `<track kind="subtitles" src={captionsSrc}>` element. Toggle via textTracks[0].mode = 'showing'/'hidden'.
    - YouTube: Captions controlled via YouTube's own UI (documented limitation — don't build workaround).
    - toggleCaptions(): Flip captionsEnabled state, update track mode.
    - Render CC button only if captionsSrc is provided and not YouTube.

    **Volume control (WALK-11):**
    - Render volume slider (input type="range" min=0 max=1 step=0.1) and mute button.
    - handleVolumeChange: Update volume state, set on video/youtube wrapper. If volume > 0 and was muted, unmute.
    - toggleMute: Flip isMuted, set on video/youtube wrapper.

    **Scene dropdown (WALK-12):**
    - Render `<select>` with scenes as options (scene.title as label, index as value).
    - On change: jumpToScene(index) — seek video to scene.timestamp (or just advanceToScene if no video), update scene.

    **ESC abort (WALK-15):**
    - escapeHandler added to document on show(), removed on hide()/abort().
    - abort() calls overlayManager.cleanup(), resets all state, pauses video, emits walkthroughAborted.

    **Render method:**
    ```
    render() {
      if (!this.isVisible) return null;

      return (
        <Host class={{ 'theme-light': this.theme==='light', 'theme-dark': this.theme==='dark' }}>
          <div class="walkthrough-panel" part="panel" ref={(el) => this.panelEl = el}>
            {/* Drag handle */}
            <div class="drag-handle" part="drag-handle">
              <span class="panel-title">{this.getCurrentSceneTitle()}</span>
              <button class="close-btn" onClick={() => this.hide()} aria-label="Close walkthrough">&times;</button>
            </div>

            {/* Video area */}
            <div class="video-container" part="video-container">
              {this.videoSrc && !this.isYouTube && this.renderNativeVideo()}
              {this.videoSrc && this.isYouTube && this.renderYouTubeContainer()}
              {!this.videoSrc && this.renderManualModePlaceholder()}
            </div>

            {/* Scene info */}
            {this.currentSceneIndex >= 0 && this.renderSceneInfo()}

            {/* Controls bar */}
            <div class="controls-bar" part="controls">
              {this.renderNavigationControls()}
              {this.renderSceneDropdown()}
              {this.videoSrc && this.renderVolumeControls()}
              {this.captionsSrc && !this.isYouTube && this.renderCaptionToggle()}
            </div>
          </div>
        </Host>
      );
    }
    ```

    **CSS file (sp-walkthrough.css):**

    Follow sp-org-chart.css patterns — consume DWC tokens with var(--dwc-*) throughout.

    - `:host` — display: block, position: fixed, z-index: 10001, bottom: 20px, right: 20px, font-family: var(--dwc-font-family)
    - `:host(:not([is-visible]))` or conditional rendering approach — hide when not visible
    - `.walkthrough-panel` — width 380px, max-height 80vh, background var(--dwc-color-surface, #ffffff), border 1px solid var(--dwc-color-border), border-radius var(--dwc-border-radius, 8px), box-shadow var(--dwc-shadow-lg, 0 10px 25px rgba(0,0,0,0.15)), overflow hidden, display flex, flex-direction column
    - `.drag-handle` — padding 8px 12px, background var(--dwc-color-surface-alt, #f8f9fa), border-bottom 1px solid var(--dwc-color-border), cursor grab, display flex, justify-content space-between, align-items center, user-select none
    - `.drag-handle:active` — cursor grabbing
    - `.panel-title` — font-weight var(--dwc-font-weight-semibold), font-size var(--dwc-font-size-sm), color var(--dwc-color-text), overflow hidden, text-overflow ellipsis, white-space nowrap, flex 1
    - `.close-btn` — background none, border none, font-size 18px, cursor pointer, color var(--dwc-color-text-secondary), padding 0 4px, line-height 1
    - `.close-btn:hover` — color var(--dwc-color-text)
    - `.video-container` — position relative, width 100%, aspect-ratio 16/9, background var(--dwc-color-surface-alt, #000), overflow hidden
    - `.video-container video` — width 100%, height 100%, object-fit contain
    - `.video-container iframe` — width 100%, height 100%, border none
    - `.manual-mode-placeholder` — display flex, align-items center, justify-content center, height 100%, color var(--dwc-color-text-secondary), font-size var(--dwc-font-size-sm), padding var(--dwc-spacing-md)
    - `.scene-info` — padding 12px, border-bottom 1px solid var(--dwc-color-border)
    - `.scene-info .scene-title` — font-weight var(--dwc-font-weight-semibold), margin-bottom 4px
    - `.scene-info .scene-description` — font-size var(--dwc-font-size-sm), color var(--dwc-color-text-secondary), line-height 1.4
    - `.controls-bar` — padding 8px 12px, display flex, align-items center, gap 8px, flex-wrap wrap, border-top 1px solid var(--dwc-color-border)
    - `.nav-buttons` — display flex, align-items center, gap 4px
    - `.nav-buttons button` — background none, border 1px solid var(--dwc-color-border), border-radius var(--dwc-border-radius, 4px), padding 4px 8px, cursor pointer, font-size var(--dwc-font-size-sm), color var(--dwc-color-text)
    - `.nav-buttons button:hover:not(:disabled)` — background var(--dwc-color-surface-alt), border-color var(--dwc-color-primary)
    - `.nav-buttons button:disabled` — opacity 0.4, cursor not-allowed
    - `.scene-counter` — font-size var(--dwc-font-size-xs), color var(--dwc-color-text-secondary), min-width 40px, text-align center
    - `.scene-selector` — flex 1, min-width 0, padding 4px, border 1px solid var(--dwc-color-border), border-radius var(--dwc-border-radius, 4px), font-size var(--dwc-font-size-sm), font-family var(--dwc-font-family), background var(--dwc-color-surface), color var(--dwc-color-text)
    - `.volume-controls` — display flex, align-items center, gap 4px
    - `.volume-controls button` — background none, border none, cursor pointer, font-size 14px, padding 2px, color var(--dwc-color-text)
    - `.volume-controls input[type="range"]` — width 60px, accent-color var(--dwc-color-primary)
    - `.caption-toggle` — background none, border 1px solid var(--dwc-color-border), border-radius var(--dwc-border-radius, 4px), padding 2px 6px, cursor pointer, font-size var(--dwc-font-size-xs), font-weight var(--dwc-font-weight-semibold), color var(--dwc-color-text-secondary)
    - `.caption-toggle.active` — background var(--dwc-color-primary), color white, border-color var(--dwc-color-primary)
    - Theme overrides: :host(.theme-light) and :host(.theme-dark) following sp-example/sp-org-chart patterns

    **Demo in src/index.html:**
    Add a walkthrough demo section after the existing org-chart demo. Include:
    - An sp-walkthrough element with id
    - Script that configures scenes array with 3 sample scenes (timestamps 0, 5, 10) highlighting different page elements (e.g., '#org-chart-demo h3', '.filter-input', etc.)
    - A button to call walkthroughEl.show() to trigger the walkthrough
    - Event listener logging scene changes to console
    - Use a free sample video URL or leave videoSrc empty for manual navigation demo
  </action>
  <verify>
    Run `npm run build` — build succeeds without errors.
    Add demo to src/index.html and run `npm start` to verify:
    1. Walkthrough panel appears when show() called
    2. Panel is draggable
    3. Manual navigation (prev/next) works if no video
    4. Scene dropdown lists all scenes
    5. ESC closes the walkthrough
    6. No console errors
    Run `npx tsc --noEmit` — no TypeScript errors.
  </verify>
  <done>
    sp-walkthrough component renders fixed-position panel with video playback (standard + YouTube).
    Timeline engine advances scenes at configured timestamps during playback.
    Overlay manager highlights DOM elements outside shadow boundary with spotlight effect.
    Manual prev/next navigation works when no video present.
    Panel is draggable via drag handle with viewport constraints.
    Volume slider and mute toggle control playback volume.
    Caption toggle shows/hides WebVTT subtitles (standard video only).
    Scene dropdown allows jumping to specific scenes.
    ESC key aborts walkthrough with full cleanup.
    Events emitted: walkthrough-shown, walkthrough-hidden, walkthrough-aborted, scene-changed.
    Public API: show(), hide(), play(), pause(), restart(), abort().
    All DWC tokens consumed for consistent theming.
    WALK-01 through WALK-06 and WALK-10 through WALK-15 implemented.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes without errors
2. `npx tsc --noEmit` passes — no TypeScript errors
3. Component renders in dev server (`npm start`) showing walkthrough panel
4. Video playback works (or manual navigation if no video)
5. Scene dropdown navigates between scenes
6. DOM element highlighting appears outside shadow boundary
7. Panel is draggable with viewport constraints
8. Volume/mute controls function
9. ESC key aborts walkthrough and cleans up overlays
10. Events fire correctly (check console in demo)
</verification>

<success_criteria>
- Requirements WALK-01 through WALK-06 and WALK-10 through WALK-15 implemented
- Component follows established patterns (DWC theming, Shadow DOM, events, props, methods)
- Utility modules are pure and separated from component logic
- Build produces dist output without errors
- Component is ready for author mode extension (Plan 02) and test suite (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/03-walkthrough-component/03-01-SUMMARY.md`
</output>
