---
phase: 05-testing-quality
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/sp-markdown-editor/sp-markdown-editor.spec.ts
  - src/components/sp-markdown-editor/utils/markdown-renderer.spec.ts
autonomous: true

must_haves:
  truths:
    - "sp-markdown-editor has sufficient spec test coverage for uncovered mode switching, toolbar actions, auto-save, voice dictation, import/export, and render methods"
    - "sp-markdown-editor renders with readable defaults when DWC theme is not loaded"
    - "markdown-renderer.ts uncovered branch at lines 55-67 is tested"
  artifacts:
    - path: "src/components/sp-markdown-editor/sp-markdown-editor.spec.ts"
      provides: "Expanded markdown editor tests covering interaction handlers, modes, and fallback rendering"
    - path: "src/components/sp-markdown-editor/utils/markdown-renderer.spec.ts"
      provides: "Tests covering remaining uncovered branches"
  key_links:
    - from: "src/components/sp-markdown-editor/sp-markdown-editor.spec.ts"
      to: "src/components/sp-markdown-editor/sp-markdown-editor.tsx"
      via: "newSpecPage component testing"
      pattern: "newSpecPage.*SpMarkdownEditor"
---

<objective>
Add targeted spec tests for sp-markdown-editor to close coverage gaps from 40.43% to 70%+ and validate fallback rendering without DWC theme.

Purpose: Bring sp-markdown-editor.tsx from 40.43% to 70%+ statement coverage by testing mode switching, toolbar integration, auto-save, voice dictation, import/export, and print functionality. Also validate the component renders with sensible defaults without DWC theme loaded.
Output: Expanded sp-markdown-editor.spec.ts with comprehensive tests, minor additions to markdown-renderer.spec.ts.
</objective>

<execution_context>
@/Users/beff/.claude/get-shit-done/workflows/execute-plan.md
@/Users/beff/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-testing-quality/05-RESEARCH.md
@src/components/sp-markdown-editor/sp-markdown-editor.tsx
@src/components/sp-markdown-editor/sp-markdown-editor.spec.ts
@src/components/sp-markdown-editor/sp-markdown-editor.css
@src/components/sp-markdown-editor/utils/markdown-renderer.ts
@src/components/sp-markdown-editor/utils/markdown-renderer.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add sp-markdown-editor coverage gap tests</name>
  <files>src/components/sp-markdown-editor/sp-markdown-editor.spec.ts, src/components/sp-markdown-editor/utils/markdown-renderer.spec.ts</files>
  <action>
  Add targeted spec tests to sp-markdown-editor.spec.ts covering uncovered lines. Current coverage is 40.43% statements. Key uncovered areas (from coverage report: lines 102-112, 198, 203, 215, 230, 255-266, 313-327, 338-368, 374-406, 412-467, 473-563, 568-618, 634-646, 674-810):

  **Mode switching (lines 102-112, 674-810):**
  1. Test setMode('source'): verify textarea is rendered, content preserved.
  2. Test setMode('wysiwyg'): verify preview div is rendered with HTML content. Mock marked/DOMPurify if needed.
  3. Test setMode('split'): verify both source and preview panes are rendered side-by-side.
  4. Test mode-change event emission when switching modes.
  5. Test content preservation across mode switches (set content in source, switch to wysiwyg, switch back, verify content unchanged).

  **Auto-save and dirty state (lines 255-266):**
  6. Test auto-save timer: set content, advance timers with jest.useFakeTimers, verify save event emits after debounce period (2000ms).
  7. Test isDirty(): returns false initially, true after content modification, false after save.
  8. Test content-change event: fires on textarea input with current content.

  **Toolbar action handlers (lines 313-327, 338-368):**
  9. Test handleToolbarAction for bold: verify content wraps with ** markers.
  10. Test handleToolbarAction for italic, strikethrough, code, heading levels.
  11. Test handleToolbarAction for link insertion: verify [text](url) pattern inserted.
  12. Test handleToolbarAction for image insertion.
  13. Test handleToolbarAction for list (ordered and unordered).
  14. Test handleToolbarAction for blockquote and horizontal rule.
  15. Test handleToolbarAction for table insertion.

  **Keyboard shortcuts (lines 374-406):**
  16. Test Ctrl+B triggers bold. Mock KeyboardEvent with ctrlKey=true, key='b'.
  17. Test Ctrl+I triggers italic.
  18. Test Ctrl+K triggers link.
  19. Test Ctrl+S triggers save event.
  20. Test Ctrl+Z triggers undo, Ctrl+Shift+Z triggers redo.

  **Voice dictation (lines 412-467):**
  21. Mock SpeechRecognition on window. Test startVoiceInput: verify recognition.start() called.
  22. Test stopVoiceInput: verify recognition.stop() called.
  23. Test voice result handling: simulate onresult event, verify content is appended to editor.
  24. Test voice error handling: simulate onerror event, verify graceful recovery.

  **Import/export (lines 473-563):**
  25. Mock FileReader. Test loadFromFile: provide mock .md File, simulate FileReader onload, verify content loaded.
  26. Test exportToFile: verify it creates a download link with correct blob content and .md extension. Mock URL.createObjectURL and document.createElement('a').click.
  27. Test import event emission after file load.
  28. Test export event emission after file export.

  **Print (lines 568-618):**
  29. Mock window.open. Test print: verify it opens new window with formatted content.

  **Public API methods (lines 634-646):**
  30. Test getContent() returns current content.
  31. Test setContent(value) updates content and renders.
  32. Test clear() resets content to empty string.
  33. Test getMode() returns current mode.
  34. Test focusEditor() calls focus on textarea.

  **Render variations (lines 674-810):**
  35. Test rendering with toolbar visible: verify toolbar buttons are present.
  36. Test rendering with footer: verify word count and character count display.
  37. Test rendering with auto-save indicator when dirty.

  **markdown-renderer.spec.ts** (lines 55-67 uncovered):
  38. Add tests for the uncovered branch in markdown-renderer.ts -- likely the fallback path when marked/DOMPurify are not available. Test that render returns raw text or sanitized HTML when peer dependencies are missing.

  Target: Bring sp-markdown-editor.tsx from ~40.43% to 70%+ statement coverage. Use jest.useFakeTimers() for debounce/auto-save tests. Mock browser APIs (SpeechRecognition, FileReader, window.open, URL.createObjectURL) as needed.
  </action>
  <verify>
  Run `npx stencil test --spec src/components/sp-markdown-editor/ -- --coverage 2>&1 | grep -E "(sp-markdown-editor.tsx|markdown-renderer.ts)"` and verify both files show >= 70% statement coverage.
  </verify>
  <done>sp-markdown-editor.tsx has >= 70% statement coverage with tests covering mode switching, toolbar actions, keyboard shortcuts, auto-save, voice dictation, import/export, print, and public API. markdown-renderer.ts uncovered branch is tested.</done>
</task>

<task type="auto">
  <name>Task 2: Add sp-markdown-editor fallback rendering tests</name>
  <files>src/components/sp-markdown-editor/sp-markdown-editor.spec.ts</files>
  <action>
  Add a new `describe('fallback rendering without DWC theme', () => { ... })` block to sp-markdown-editor.spec.ts that validates the component renders with usable defaults when no DWC theme tokens are loaded:

  1. **Component renders without errors**: Create page with newSpecPage, verify page.root is truthy and no errors thrown.

  2. **Editor structure intact**: Verify the component renders with:
     - A toolbar container with formatting buttons
     - A textarea (source mode) or preview area
     - A footer with word/character count

  3. **Interactive elements are present**: Verify toolbar buttons are rendered and have text content (B, I, S, H1, etc.). Buttons should be clickable (not disabled).

  4. **Content area is functional**: Set content via setContent(), verify the textarea value reflects the content. Verify getContent() returns the set value.

  5. **Footer displays counts**: After setting content "Hello world", verify footer shows word count of 2 and character count of 11.

  6. **Mode switching works without theme**: Switch between source/wysiwyg/split modes, verify no errors and appropriate elements render for each mode.

  The key insight: without DWC theme, the component uses CSS fallback values (system fonts, neutral grays). These tests verify the component FUNCTIONS correctly without the theme -- the structure and interactivity work regardless of visual theming.
  </action>
  <verify>
  Run `npx stencil test --spec src/components/sp-markdown-editor/sp-markdown-editor.spec.ts -- --coverage 2>&1 | grep "sp-markdown-editor.tsx"` and verify statement coverage >= 70%. Also verify the test count increased.
  </verify>
  <done>sp-markdown-editor fallback rendering tests verify component structure, toolbar, content area, footer, and mode switching all work without DWC theme loaded.</done>
</task>

</tasks>

<verification>
1. sp-markdown-editor.tsx coverage >= 70% across all metrics (statements, branches, functions, lines)
2. markdown-renderer.ts coverage improved (uncovered branch at lines 55-67 tested)
3. All existing tests still pass (no regressions)
4. Fallback rendering test block exists and passes for sp-markdown-editor
5. Run full suite: `npx stencil test --spec -- --coverage` to see global coverage approaching 70%
</verification>

<success_criteria>
- sp-markdown-editor.tsx statement coverage >= 70%
- markdown-renderer.ts has no significant uncovered branches
- Fallback rendering tests verify editor renders and functions without DWC theme
- All tests pass with no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/05-testing-quality/05-03-SUMMARY.md`
</output>
